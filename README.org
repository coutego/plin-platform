* PLIN Platform

*PLIN* (PLuggable & INjectable) is a data-driven plugin architecture for ClojureScript applications.
This repository contains the *PLIN Platform*, a set of core libraries and standard plugins to build modular SPAs.

** Quick Start (Demo)

To see the platform in action (the demo application included in this repo):

#+BEGIN_SRC bash
npm install
npm start
#+END_SRC

Open [[http://localhost:8000/?mode=demo]]

** Creating a New Application

To create a new application based on PLIN Platform, you can use the initialization script.

*** 1. Run the Initialization Script

#+BEGIN_SRC bash
# Using npx (recommended - uses the published npm package)
npx --package=plin-platform create-plin-app my-app

# Or if developing locally, run from the repo root:
node bin/create-plin-app.js my-app
#+END_SRC

This command will:
1. Create a new directory ~my-app~.
2. Generate configuration files (~package.json~, ~nbb.edn~, ~plin.edn~).
3. Create a sample plugin with a basic UI.
4. Install dependencies automatically.

*** 2. Start Your App

#+BEGIN_SRC bash
cd my-app
npm start
#+END_SRC

Open [[http://localhost:8000]]. You will see the PLIN App Shell with your new plugin loaded alongside the standard platform features (Navigation, Auth, Admin, etc.).

*** 3. Build for demo mode

To generate a single-file HTML bundle (zero dependencies, easy deployment):

#+BEGIN_SRC bash
npm run build
#+END_SRC

The output will be at ~target/index.html~.

** Configuration & Manifest

The *Manifest* (~plin.edn~) is the entry point for your application. It tells the bootstrapper which plugins to load.

*** Default Behavior
By default, the PLIN Platform loads a standard set of plugins (App Shell, Navigation, Authentication, Admin UI, etc.) *before* loading your application plugins. This allows you to start building features immediately without wiring up infrastructure.

*** Opting Out (Bare Bones Mode)
If you want full control and do *not* want the standard platform plugins loaded automatically, add a config entry to your ~plin.edn~:

#+BEGIN_SRC clojure
[{:config {:include-platform? false}} ;; <--- Disables standard plugins
 {:id :my-app
  :tags [:ui]
  :files ["src/my_app/core.cljs"]
  :entry "my-app.core"}]
#+END_SRC

** Core Concepts

*** Interface vs. Implementation
You will notice plugins in ~libs/plinpt~ are paired:
- *~i-database~* (Interface): Defines the contract (beans, extension points) but no logic.
- *~p-alasql-db~* (Implementation): Provides the actual logic.

This is a useful practice, strongly recommended for bigger applications.
*Rule*: Your code should depend on *Interfaces* (~i-*~), not specific *Implementations* (~p-*~). This allows you to swap the provider without cascading dependencies.
It also allows to have what are effectively run-time circular dependencies in a safe and controlled way. Two plugins can interact with each other through
the interfaces, so it's only at runtime that they will cross-referencing each other, not at build or bootstrap time.

*** Dependency Injection
Everything in PLIN is a "Bean". Beans are defined in the ~:beans~ map of a plugin.
- *Values*: ~[:= {:some "config"}]~
- *Functions*: ~[:= (fn [db] ...)]~
- *Components*: ~[:= my-reagent-component]~

To use a bean from another plugin, simply refer to its fully qualified keyword (e.g., ~::i-db/executor~) in your bean definition. The container handles the wiring.

*** Session & User Data (Skinnable Pattern)

The session system uses a layered abstraction to support custom skins:

1. *~::isession/user-data~*: Reactive atom with user info (~{:logged? :name :initials :avatar-url :roles :permissions}~)
2. *~::isession/user-actions~*: Map of callbacks (~{:login! :logout! :show-profile!}~)
3. *~::isession/user-widget~*: Default widget (skins can use or ignore)

These are available via the session interface (~plinpt.i-session~).

*For simple skins*: Just render ~[user-widget]~.

*For custom skins*: Build your own UI using ~@user-data~ and ~user-actions~:

#+BEGIN_SRC clojure
(defn my-custom-user-ui [user-data user-actions]
  (fn []
    (let [{:keys [logged? name initials]} @user-data
          {:keys [login! logout!]} user-actions]
      (if logged?
        [:div.my-style
         [:span initials]
         [:button {:on-click logout!} "Logout"]]
        [:button {:on-click login!} "Login"]))))
#+END_SRC

** Routing and Navigation

The PLIN Platform provides a flexible routing and navigation system with clear separation of concerns. This section summarizes the key concepts; for comprehensive details, see ~doc/routing-and-navigation.org~.

*** Three-Layer Architecture

The system separates navigation into three distinct layers:

1. *Navigation Structure* (~i-application~): Defines WHAT pages exist and how they are organized
2. *Routing* (~i-router~, ~p-hash-router~): Handles URL changes and determines WHICH page to show
3. *Shell Rendering* (~i-app-shell~, ~p-app-shell~): Controls HOW the UI is displayed

*** Nav Items: The Building Blocks

Pages are registered via *nav-items*, which are maps describing navigable locations:

#+BEGIN_SRC clojure
{:id :dashboard
 :label "Dashboard"
 :description "Main dashboard view"
 :route "dashboard"           ;; URL segment (relative to parent)
 :icon [:svg {...}]           ;; Hiccup SVG for the icon
 :icon-color "text-blue-600 bg-blue-50"
 :component dashboard-page    ;; Reagent component to render
 :parent-id :admin            ;; Optional: for nested navigation
 :required-perm :perm/admin   ;; Optional: permission required
 :order 1                     ;; Sort order (lower = first)
 :extra {...}}                ;; Optional: application-specific data
#+END_SRC

Plugins contribute nav-items via the ~::iapp/nav-items~ extension:

#+BEGIN_SRC clojure
:contributions
{::iapp/nav-items [{:id :my-feature
                    :label "My Feature"
                    :route "my-feature"
                    :component my-page
                    :order 10}]}
#+END_SRC

*** The ~:extra~ Field

The ~:extra~ field allows applications to attach arbitrary metadata to nav-items. This is useful for:

- Custom sidebar renderers that need additional styling or behavior hints
- Feature flags or conditional rendering logic
- Analytics tracking data
- Custom shell implementations that need app-specific information

#+BEGIN_SRC clojure
{:id :reports
 :label "Reports"
 :route "reports"
 :component reports-page
 :extra {:sidebar-style :compact      ;; Custom rendering hint
         :badge-count 5               ;; Show notification badge
         :feature-flag :beta-reports  ;; Feature gating
         :analytics-id "nav-reports"  ;; Tracking
         :custom-renderer my-renderer ;; Custom component for sidebar
         }}
#+END_SRC

The platform's default shell and sidebar implementations pass through the ~:extra~ field unchanged, allowing custom shells to access and use this data as needed.

*** Hierarchical Navigation

Nav items can be nested using ~:parent-id~:

#+BEGIN_SRC clojure
;; Root section (no component = auto-generated parent page)
{:id :settings
 :label "Settings"
 :route "/settings"
 :icon settings-icon
 :order 100}

;; Child items
{:id :profile
 :parent-id :settings
 :label "Profile"
 :route "profile"
 :component profile-page
 :order 1}
#+END_SRC

This creates:
- ~/settings~ - Parent page (auto-generated with cards linking to children)
- ~/settings/profile~ - Profile page

*** Key Beans for Custom Shells

When building custom shells, these beans are essential:

| Bean                        | Purpose                              |
|-----------------------------|--------------------------------------|
| ~::iapp/structure~          | Navigation tree (hierarchical)       |
| ~::irouter/current-route~   | Current route (reactive atom)        |
| ~::irouter/navigate!~       | Navigation function                  |
| ~::irouter/setup!~          | Router initialization                |
| ~::iauth/can?~              | Permission checking                  |
| ~::isession/user-data~      | User info for UI                     |
| ~::isession/user-actions~   | Login/logout callbacks               |
| ~::iapp/overlay-components~ | Global overlays                      |
| ~::iapp/homepage~           | Homepage configuration               |

*** Customization Levels

1. *Adding Pages*: Contribute nav-items with components
2. *Adding Overlays*: Contribute to ~::iapp/overlay-components~
3. *Customizing Homepage*: Override ~::iapp/homepage~
4. *Customizing Metadata*: Override ~::iapp/name~, ~::iapp/logo~, etc.
5. *Replacing the Shell*: Override ~::iapp/ui~ with your own layout
6. *Replacing the Router*: Override ~::irouter/*~ beans for different routing strategies

*** Further Information

For detailed architecture documentation, including complete examples of custom shells and routers, see ~doc/routing-and-navigation.org~.

** Architecture

This repository is organized to separate the "Platform" code from "User" code.

- *~libs/plin~*: The core framework (Bootstrapper, IoC Container).
- *~libs/plinpt~*: The *PLIN Platform*. A standard library of plugins (Admin UI, Auth, Database, UI Components).
- *~src/plin_platform~*: Server and Build tools.

*** Configuration Files

- *~nbb.edn~*: Configuration for nbb (Node Babashka) - specifies source paths for the ClojureScript runtime.
- *~package.json~*: npm package configuration with dependencies and scripts.
- *~plin.edn~*: Plugin manifest that defines which plugins to load.

*** How It Works

**** Client (Browser)
The browser loads ~public/index.html~, which:
1. Fetches and parses the manifest (~plin.edn~)
2. Dynamically loads script tags for each plugin file
3. Bootstraps the application via ~client_boot.cljs~

**** Server (Node.js / nbb)
The server uses a two-phase approach because ~nbb~ cannot dynamically require namespaces:

1. *Generation Phase*: ~bin/generate-server-boot.js~ reads the manifest and generates ~target/server_boot_generated.cljs~ with hardcoded requires for all server plugins.
2. *Execution Phase*: ~nbb~ runs the generated file, which has all necessary namespaces statically required.

When you run ~npm start~, both phases happen automatically.

*** Development vs Production

| Command | Description |
|---------|-------------|
| ~npm start~ | Generates boot file and starts server (recommended) |
| ~npm run start:dev~ | Uses static server_boot.cljs (for framework development) |
| ~npm run generate-boot~ | Only generates the boot file without running |
| ~npm run build~ | Creates single-file HTML bundle |

** Tutorial: Creating Your First Plugin

Let's add a simple "Hello World" feature to the application.

*** Step 1: Create the Plugin File
Create a new file at ~src/showcase/hello.cljs~:

#+BEGIN_SRC clojure
(ns showcase.hello
  (:require [plin.core :as plin]
            [plinpt.i-application :as iapp])) ;; Central interface for app structure

;; 1. Define the UI Component
(defn hello-page []
  [:div {:class "p-10"}
   [:h1 {:class "text-4xl font-bold text-blue-600"} "Hello, PLIN!"]
   [:p {:class "mt-4 text-gray-600"} "This is my first custom plugin."]])

;; 2. Define the Plugin Definition
(def plugin
  (plin/plugin
   {:doc "My first custom plugin."
    ;; Declare dependencies on the interfaces we use
    :deps [iapp/plugin]

    ;; Contribute to extensions defined by other plugins
    :contributions
    {;; Add a link to the Navigation Bar using the Bean Constructor Pattern
     ::iapp/nav-items [::nav-item]}

    ;; Define beans (internal components)
    :beans
    {;; The page component bean
     ::ui
     ^{:doc "Hello page component."
       :reagent-component true}
     [:= hello-page]

     ;; The navigation item bean (uses constructor pattern for dependency injection)
     ::nav-item
     ^{:doc "Navigation item with injected component"}
     {:constructor [(fn [ui]
                      {:id :hello
                       :label "Hello"
                       :route "hello"
                       :icon [:svg {:class "h-5 w-5" :fill "none" :viewBox "0 0 24 24" :stroke "currentColor"}
                              [:path {:stroke-linecap "round" :stroke-linejoin "round" :stroke-width "2" 
                                      :d "M14.828 14.828a4 4 0 01-5.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"}]]
                       :component ui
                       :order 1})
                    ::ui]}}}))
#+END_SRC

*** Step 2: Test with Dynamic Loader (Optional)
Before registering the plugin permanently, you can test it live without restarting the server.

1.  Open the application in your browser.
2.  Navigate to *Development* -> *Dynamic Loader*.
3.  Upload your ~src/showcase/hello.cljs~ file.
4.  The system will compile the file, reload the container, and your "Hello" link should appear in the sidebar immediately.

*** Step 3: Register in Manifest
To make the plugin permanent, open ~plin.edn~ (in your project root) and add your new plugin to the vector.
*Note*: Ensure you add the ~:ui~ tag so it loads in the browser.

#+BEGIN_SRC clojure
[
  ...
  {:id :showcase-hello
   :tags [:ui]
   :files ["src/showcase/hello.cljs"]
   :entry "showcase.hello"}
]
#+END_SRC

*** Step 4: Reload
Refresh your browser. You should see a "Hello" link in the sidebar, which leads to your new page.

** More Examples

The examples below demonstrate various PLIN Platform features. You can test any of these examples *without modifying the manifest* by using the Dynamic Plugin Loader:

1. Open the application in your browser
2. Navigate to *Development* -> *Dynamic Loader*
3. Copy the example code into a ~.cljs~ file
4. Upload the file using the loader interface
5. The plugin will be compiled and loaded immediately

This allows rapid prototyping and experimentation before committing changes to your manifest.

*** Example 1: Global Command Palette

This example demonstrates how to create a global overlay component (triggered by keyboard shortcuts) that interacts with the routing system. It features fuzzy search and keyboard navigation.

**** Step 1: Create the Plugin File
Create ~src/showcase/command_palette.cljs~:

#+BEGIN_SRC clojure
(ns showcase.command-palette
  (:require [reagent.core :as r]
            [clojure.string :as str]
            [plin.core :as plin]
            [plinpt.i-application :as iapp]))

;; --- State ---

(defonce state (r/atom {:open? false
                        :query ""
                        :selected-index 0}))

;; --- Logic ---

(defn toggle! []
  (swap! state update :open? not)
  (when (:open? @state)
    (swap! state assoc :query "" :selected-index 0)))

(defn close! []
  (swap! state assoc :open? false))

(defn navigate! [route]
  (when route
    (set! (.-hash js/location) (:path route))
    (close!)))

(defn fuzzy-match? [query text]
  (let [q (str/replace (str/lower-case query) #"\s+" "")
        t (str/lower-case text)]
    (loop [qi 0 ti 0]
      (cond
        (= qi (count q)) true
        (= ti (count t)) false
        (= (nth q qi) (nth t ti)) (recur (inc qi) (inc ti))
        :else (recur qi (inc ti))))))

(defn filter-routes [routes query]
  (let [candidates (->> routes
                        (filter :path)
                        (sort-by :path))]
    (if (str/blank? query)
      (take 100 candidates)
      (->> candidates
           (filter #(fuzzy-match? query (:path %)))
           (take 100)))))

(defn handle-input-keydown [e filtered selected-index]
  (let [max-idx (dec (count filtered))]
    (condp = (.-key e)
      "ArrowDown" (do (.preventDefault e)
                      (swap! state update :selected-index #(min (inc %) max-idx)))
      "ArrowUp"   (do (.preventDefault e)
                      (swap! state update :selected-index #(max (dec %) 0)))
      "Enter"     (do (.preventDefault e)
                      (navigate! (nth filtered selected-index nil)))
      "Escape"    (close!)
      nil)))

;; --- Sub-Components ---

(defn search-input [query filtered selected-index]
  [:div {:class "flex items-center border-b border-slate-700 px-4"}
   [:svg {:class "w-5 h-5 text-slate-500 mr-3" :fill "none" :stroke "currentColor" :viewBox "0 0 24 24"}
    [:path {:stroke-linecap "round" :stroke-linejoin "round" :stroke-width "2" :d "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"}]]
   [:input {:id "cmd-palette-input"
            :type "text"
            :auto-focus true
            :class "flex-1 h-14 outline-none text-white placeholder:text-slate-500 bg-transparent text-lg"
            :placeholder "Go to..."
            :value query
            :on-change #(swap! state assoc :query (.. % -target -value) :selected-index 0)
            :on-key-down #(handle-input-keydown % filtered selected-index)}]])

(defn result-item [idx route selected-index]
  (let [selected? (= idx selected-index)]
    [:div {:id (when selected? "cmd-palette-selected")
           :class (str "px-4 py-3 mx-2 rounded-lg cursor-pointer flex items-center justify-between transition-colors "
                       (if selected?
                         "bg-blue-600 text-white"
                         "text-slate-300 hover:bg-slate-700/50"))
           :on-click #(navigate! route)
           :on-mouse-move #(when-not selected?
                             (swap! state assoc :selected-index idx))}

     [:div {:class "flex items-center gap-3"}
      [:svg {:class (str "w-4 h-4 " (if selected? "text-blue-200" "text-slate-500"))
             :fill "none" :stroke "currentColor" :viewBox "0 0 24 24"}
       [:path {:stroke-linecap "round" :stroke-linejoin "round" :stroke-width "2" :d "M13 7l5 5m0 0l-5 5m5-5H6"}]]

      [:span {:class "font-mono text-sm"} (:path route)]]

     (when selected?
       [:span {:class "text-xs text-blue-200 font-bold opacity-75"} "⏎"])]))

(defn results-list [filtered selected-index]
  (if (empty? filtered)
    [:div {:class "p-8 text-center text-slate-500"}
     [:div "No matching routes found."]]

    ;; Added [&::-webkit-scrollbar]:hidden to hide scrollbar in WebKit
    ;; Added style for Firefox/IE
    [:div {:class "max-h-[60vh] overflow-y-auto py-2 scroll-smooth [&::-webkit-scrollbar]:hidden"
           :style {:scrollbar-width "none" :ms-overflow-style "none"}}
     (doall
      (for [[idx route] (map-indexed vector filtered)]
        ^{:key (:path route)}
        [result-item idx route selected-index]))]))

(defn palette-footer []
  [:div {:class "bg-slate-900/50 px-4 py-2 text-xs text-slate-500 flex justify-between border-t border-slate-700"}
   [:div {:class "flex gap-3"}
    [:span "↑↓ to navigate"]
    [:span "↵ to select"]
    [:span "esc to close"]]
   [:span "PLIN Command Palette"]])

;; --- Main Component ---

(defn palette-component [routes]
  (let [listener-fn (atom nil)]
    (r/create-class
     {:component-did-mount
      (fn []
        (let [handler (fn [e]
                        (when (and (or (.-ctrlKey e) (.-metaKey e))
                                   (= (str/lower-case (.-key e)) "k"))
                          (.preventDefault e)
                          (toggle!)))]
          (reset! listener-fn handler)
          (js/window.addEventListener "keydown" handler)))

      :component-will-unmount
      (fn []
        (when @listener-fn
          (js/window.removeEventListener "keydown" @listener-fn)))

      :component-did-update
      (fn []
        (when (:open? @state)
          (when-let [el (.getElementById js/document "cmd-palette-input")]
            (.focus el))
          (when-let [el (.getElementById js/document "cmd-palette-selected")]
            (.scrollIntoView el #js {:block "nearest"}))))

      :reagent-render
      (fn []
        (let [{:keys [open? query selected-index]} @state
              filtered (filter-routes routes query)]

          (when open?
            [:div {:class "fixed inset-0 z-[100] flex items-start justify-center pt-[15vh] font-sans"}
             ;; Backdrop
             [:div {:class "absolute inset-0 bg-black/60 backdrop-blur-sm transition-opacity"
                    :on-click close!}]

             ;; Modal
             [:div {:class "relative w-full max-w-xl bg-slate-800 border border-slate-700 rounded-xl shadow-2xl overflow-hidden flex flex-col animate-in fade-in zoom-in-95 duration-100"}
              [search-input query filtered selected-index]
              [results-list filtered selected-index]
              [palette-footer]]])))})))

(def plugin
  (plin/plugin
   {:doc "A global command palette triggered by Ctrl+K / Cmd+K."
    :deps [iapp/plugin]

    :contributions
    {::iapp/overlay-components [::ui]}

    :beans
    {::ui
     ^{:doc "The Command Palette Overlay Component."
       :reagent-component true
       :api {:args [] :ret :hiccup}}
     [partial palette-component ::iapp/all-routes]}}))
#+END_SRC

**** Step 2: Test with Dynamic Loader
You can test this immediately using the Dynamic Loader (*Development* -> *Dynamic Loader*). Upload the file and press ~Ctrl+K~ or ~Cmd+K~ to open the palette.

**** Step 3: Register in Manifest (Optional)
To make the plugin permanent, add to ~plin.edn~:

#+BEGIN_SRC clojure
{:id :showcase-command-palette
 :tags [:ui]
 :files ["src/showcase/command_palette.cljs"]
 :entry "showcase.command-palette"}
#+END_SRC

*** Example 2: Zen Mode
