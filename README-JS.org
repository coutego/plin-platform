#+TITLE: JavaScript/TypeScript Plugin Development Guide
#+AUTHOR: PLIN Platform
#+OPTIONS: toc:3 num:nil

* Overview

PLIN Platform supports plugins written in JavaScript, TypeScript, and JSX/TSX. This guide covers all approaches to JS-based plugin development.

** Plugin Types

| Approach | File Extension | Build Required | Best For |
|----------+----------------+----------------+----------|
| Plain JS | =.js= | No | Simple plugins, quick prototypes |
| JSX/TSX | =.tsx=, =.jsx= | Yes (esbuild) | Complex UIs, type safety |

All JS-based plugins are loaded dynamically by the platform and wrapped for compatibility with the Reagent/ClojureScript core.

** Example Plugins

The platform includes working example plugins you can reference:

- =src/plinpt_extras/showcase/game_2048.js= - Complete 2048 game demonstrating React state, keyboard handling, and plin utilities
- =src/plinpt_extras/showcase/plugin_inspector.js= - System introspection plugin showing *useAtom* for reactive state, data access utilities, and plugin management

* Quick Start

** Plain JavaScript Plugin

Create a =.js= file that returns a plugin definition:

#+BEGIN_SRC javascript
// my-plugin.js
const MyPage = () => {
    return React.createElement("div", { className: "p-6" },
        React.createElement("h1", null, "Hello World")
    );
};

return {
    doc: "My Plugin",
    deps: ["plinpt.i-application"],
    contributions: {
        "plinpt.i-application/nav-items": [{
            id: "my-page",
            label: "My Page",
            route: "/my-page",
            icon: "icon",
            component: "page",
            order: 100
        }]
    },
    beans: {
        "page": { type: "react-component", value: MyPage },
        "icon": { type: "hiccup", value: ["svg", {/*...*/}] }
    }
};
#+END_SRC

Register in =plin.edn=:

#+BEGIN_SRC clojure
{:id :my-app.my-plugin
 :type :js
 :envs [:browser]
 :files ["path/to/my-plugin.js"]}
#+END_SRC

** JSX/TSX Plugin

1. Create a =.tsx= file in =plugins-src/=:

#+BEGIN_SRC typescript
// plugins-src/my-plugin.tsx
import React, { useState } from 'react';

const MyPage: React.FC = () => {
  const [count, setCount] = useState(0);
  return (
    <div className="p-6">
      <h1>Count: {count}</h1>
      <button onClick={() => setCount(c => c + 1)}>+</button>
    </div>
  );
};

export default {
  doc: "My TSX Plugin",
  deps: ["plinpt.i-application"],
  contributions: {
    "plinpt.i-application/nav-items": [{
      id: "my-page",
      label: "My Page", 
      route: "/my-page",
      icon: "icon",
      component: "page",
      order: 100
    }]
  },
  beans: {
    "page": { type: "react-component", value: MyPage },
    "icon": { type: "hiccup", value: ["svg", {/*...*/}] }
  }
};
#+END_SRC

2. Build the plugin:

#+BEGIN_SRC bash
npm run build:plugins
#+END_SRC

3. Register in =plin.edn=:

#+BEGIN_SRC clojure
{:id :my-app.my-plugin
 :type :js
 :envs [:browser]
 :files ["public/plugins/my-plugin.js"]}
#+END_SRC

* Plin Utilities API

The =plinpt.i-js-utils/api= bean provides helper functions for working with ClojureScript data structures. *Always inject this when working with CLJS data.*

** Injecting Plin Utilities

#+BEGIN_SRC javascript
// Factory function receives plin utilities
const createPageComponent = (plin) => {
    return function MyPage() {
        // Use plin utilities here
        return React.createElement("div", null, "Hello");
    };
};

// Bean definition
"page": {
    type: "react-component",
    value: createPageComponent,
    inject: ["plinpt.i-js-utils/api"]
}
#+END_SRC

** Atom Utilities

#+BEGIN_SRC javascript
// Check if a value is an atom wrapper
plin.isAtom(value)  // returns boolean

// Safely dereference - works on atoms or plain values
// NOTE: This is a ONE-TIME read, not reactive!
plin.deref(maybeAtom)  // returns the current value
#+END_SRC

** Data Access

#+BEGIN_SRC javascript
// Smart key lookup (handles CLJS keyword conversion)
plin.get(obj, "key")

// Nested access with array path
plin.getIn(obj, ["a", "b", "c"])

// Get all keys as array
plin.keys(obj)

// Get all values as array
plin.vals(obj)
#+END_SRC

** Type Checking

#+BEGIN_SRC javascript
// Check if value is a JS Set (from CLJS set)
plin.isSet(value)

// Check if value is an array
plin.isArray(value)
#+END_SRC

** Collection Utilities

#+BEGIN_SRC javascript
// Convert any collection to JS array
plin.toArray(coll)
#+END_SRC

** React Hooks

*** =plin.useAtom(atomWrapper)= - Reactive Atom Subscription

*This is the most important utility for reactive UIs.* It subscribes your component to a CLJS atom and re-renders automatically when the atom changes.

#+BEGIN_SRC javascript
// Subscribe to atom changes - component re-renders when atom updates
const value = plin.useAtom(atomWrapper);
#+END_SRC

*How it works:*
1. Gets the current value of the atom
2. Sets up a watch (subscription) on the atom
3. When the atom changes, triggers a React re-render
4. Automatically cleans up the subscription when component unmounts
5. Debounces rapid updates (~16ms) to prevent render storms

*Example - Reactive Plugin List:*

#+BEGIN_SRC javascript
const PluginList = ({ bootApi, plin }) => {
    // Get the state atom from bootApi
    const stateAtom = plin.get(bootApi, "state");
    
    // Subscribe to changes - UI updates automatically!
    const stateValue = plin.useAtom(stateAtom);
    
    // Extract data from the reactive state
    const plugins = plin.toArray(plin.get(stateValue, "all-plugins") || []);
    
    return React.createElement("div", null,
        React.createElement("h1", null, `${plugins.length} plugins loaded`),
        plugins.map((p, i) => 
            React.createElement("div", { key: i }, plin.get(p, "id"))
        )
    );
};
#+END_SRC

*Without useAtom (WRONG - won't update):*

#+BEGIN_SRC javascript
// DON'T DO THIS - component won't re-render when state changes!
const PluginList = ({ bootApi, plin }) => {
    const stateAtom = plin.get(bootApi, "state");
    const stateValue = plin.deref(stateAtom);  // One-time read only!
    // ... this will show stale data
};
#+END_SRC

*** =plin.useAtomState(atomWrapper)= - useState-like Interface

Returns =[value, setValue]= similar to React's =useState=, but backed by a CLJS atom.

#+BEGIN_SRC javascript
const [value, setValue] = plin.useAtomState(atomWrapper);

// Reset to new value
setValue(newValue);

// Update with function (like swap!)
setValue(currentValue => ({...currentValue, count: currentValue.count + 1}));
#+END_SRC

** Navigation

#+BEGIN_SRC javascript
// Navigate to a route
plin.navigate("/some/path")

// Get current route path
const path = plin.currentPath()
#+END_SRC

** Complete useAtom Example

#+BEGIN_SRC javascript
const PluginInspectorPage = ({ bootApi, plin }) => {
    // STEP 1: Get the atom reference using plin.get
    const stateAtom = plin.get(bootApi, "state");
    
    // STEP 2: Subscribe to the atom with useAtom
    // This is the KEY step - without this, UI won't update!
    const stateValue = plin.useAtom(stateAtom);
    
    // STEP 3: Extract data using plin utilities
    const plugins = plin.toArray(plin.get(stateValue, "all-plugins") || []);
    const disabledIds = plin.get(stateValue, "disabled-ids") || new Set();
    
    // plin.isSet() checks if it's a JS Set (from CLJS set)
    const disabledCount = plin.isSet(disabledIds) ? disabledIds.size : 0;
    
    // STEP 4: Render - will automatically update when state changes
    return React.createElement("div", { className: "p-6" },
        React.createElement("h1", null, `Found ${plugins.length} plugins`),
        React.createElement("p", null, `${disabledCount} disabled`)
    );
};

// Factory function for injection
const createPageComponent = (bootApi, plin) => {
    return () => React.createElement(PluginInspectorPage, { bootApi, plin });
};

// In beans:
"page": {
    type: "react-component",
    value: createPageComponent,
    inject: ["plin.boot/api", "plinpt.i-js-utils/api"]
}
#+END_SRC

* Project Setup

** Adding JSX/TSX Support to Existing Project

If you have an existing PLIN project, add JSX/TSX support:

*** 1. Install Dependencies

#+BEGIN_SRC bash
npm install --save-dev esbuild typescript @types/react
#+END_SRC

*** 2. Create Build Script

Create =esbuild.plugins.js= in your project root:

#+BEGIN_SRC javascript
const esbuild = require('esbuild');
const fs = require('fs');
const path = require('path');

const pluginsDir = './plugins-src';
const outDir = './public/plugins';

if (!fs.existsSync(outDir)) {
  fs.mkdirSync(outDir, { recursive: true });
}

const entries = fs.existsSync(pluginsDir) 
  ? fs.readdirSync(pluginsDir)
      .filter(f => /\.(tsx?|jsx)$/.test(f) && !f.endsWith('.d.ts'))
      .map(f => path.join(pluginsDir, f))
  : [];

if (entries.length === 0) {
  console.log('No JSX/TSX plugins found in', pluginsDir);
  process.exit(0);
}

const plinPlugin = {
  name: 'plin-transform',
  setup(build) {
    build.onEnd(result => {
      if (result.errors.length > 0) return;
      const outFiles = fs.readdirSync(outDir).filter(f => f.endsWith('.js'));
      for (const file of outFiles) {
        const filePath = path.join(outDir, file);
        let content = fs.readFileSync(filePath, 'utf8');
        if (!content.includes('return __PLIN_PLUGIN__')) {
          content += '\nreturn __PLIN_PLUGIN__.default;\n';
          fs.writeFileSync(filePath, content);
        }
      }
    });
  }
};

const watchMode = process.argv.includes('--watch');

const buildOptions = {
  entryPoints: entries,
  bundle: true,
  outdir: outDir,
  format: 'iife',
  globalName: '__PLIN_PLUGIN__',
  external: ['react'],
  jsx: 'automatic',
  loader: { '.tsx': 'tsx', '.ts': 'ts', '.jsx': 'jsx' },
  minify: false,
  target: ['es2020'],
  plugins: [plinPlugin],
  define: { 'process.env.NODE_ENV': '"production"' }
};

if (watchMode) {
  esbuild.context(buildOptions).then(ctx => {
    ctx.watch();
    console.log('Watching for changes...');
  });
} else {
  esbuild.build(buildOptions).then(() => {
    console.log('✓ Plugins built to', outDir);
  }).catch(() => process.exit(1));
}
#+END_SRC

*** 3. Create TypeScript Config

Create =tsconfig.json=:

#+BEGIN_SRC json
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "moduleResolution": "bundler",
    "jsx": "react-jsx",
    "strict": true,
    "noEmit": true,
    "isolatedModules": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  },
  "include": ["plugins-src/**/*.ts", "plugins-src/**/*.tsx"],
  "exclude": ["node_modules"]
}
#+END_SRC

*** 4. Add npm Scripts

Update =package.json=:

#+BEGIN_SRC json
{
  "scripts": {
    "build:plugins": "node esbuild.plugins.js",
    "watch:plugins": "node esbuild.plugins.js --watch"
  }
}
#+END_SRC

*** 5. Create Plugin Directory

#+BEGIN_SRC bash
mkdir -p plugins-src public/plugins
#+END_SRC

*** 6. Update .gitignore

Add to =.gitignore=:

#+BEGIN_SRC text
public/plugins/
#+END_SRC

** Creating a New Project with JSX Support

Use the =--jsx= flag with =@coutego/create-plin-app=:

#+BEGIN_SRC bash
npx @coutego/create-plin-app my-app --jsx
cd my-app
npm start
#+END_SRC

This sets up everything automatically, including an example TSX plugin.

* Plugin Definition Reference

** Top-Level Fields

| Field | Type | Required | Description |
|-------+------+----------+-------------|
| =doc= | string | No | Plugin description |
| =deps= | string[] | No | Plugin dependencies (namespace strings) |
| =beans= | object | Yes | Bean definitions |
| =contributions= | object | No | Contributions to extension points |
| =extensions= | array | No | Custom extension points |

** Common Dependencies

| Dependency | Purpose |
|------------+---------|
| ="plinpt.i-application"= | Adding navigation items |
| ="plinpt.i-js-utils"= | Plin utilities API (recommended) |
| ="plin.boot"= | System introspection |

** Bean Definition

#+BEGIN_SRC javascript
beans: {
  "bean-name": {
    doc: "Description",           // Optional
    type: "react-component",      // or "hiccup" or omit for default
    value: MyComponent,           // The actual value
    inject: ["plinpt.i-js-utils/api"]  // Optional: dependencies to inject
  }
}
#+END_SRC

** Bean Types

*** =react-component=

For React components. Automatically wrapped for Reagent compatibility.

#+BEGIN_SRC javascript
"page": {
  type: "react-component",
  value: () => <div>Hello</div>
}
#+END_SRC

*** =hiccup=

For static data structures (icons, etc.). Uses array format.

#+BEGIN_SRC javascript
"icon": {
  type: "hiccup",
  value: ["svg", { className: "w-5 h-5", viewBox: "0 0 24 24" },
    ["path", { d: "M12 4v16m8-8H4" }]
  ]
}
#+END_SRC

*Important:* Icons must be Hiccup (arrays), NOT React components.

*** Default

Any other value stored as-is.

#+BEGIN_SRC javascript
"config": {
  value: { theme: "dark", maxItems: 10 }
}
#+END_SRC

** Navigation Items

To add pages to the sidebar:

#+BEGIN_SRC javascript
contributions: {
  "plinpt.i-application/nav-items": [{
    id: "my-page",           // Unique identifier
    label: "My Page",        // Sidebar text
    description: "...",      // Optional tooltip
    route: "/my-page",       // URL path
    icon: "icon",            // Bean name (string)
    component: "page",       // Bean name (string)
    order: 100,              // Sort order (lower = higher)
    parentId: "tools"        // Optional: nest under parent
  }]
}
#+END_SRC

* Dependency Injection

Beans can request other beans to be injected.

** Pattern

#+BEGIN_SRC javascript
// Factory function receives injected dependencies
const createPage = (plin) => {
  // Return the actual component
  return function MyPage() {
    // plin is available via closure
    const path = plin.currentPath();
    return <div>Current path: {path}</div>;
  };
};

// Bean definition
"page": {
  type: "react-component",
  value: createPage,              // Factory function
  inject: ["plinpt.i-js-utils/api"]  // Dependencies to inject
}
#+END_SRC

** CLJS to JS Conversion

Injected CLJS values are converted:

| CLJS Type | JS Type | Access |
|-----------+---------+--------|
| Map | Object | =plin.get(obj, "key")= |
| Vector | Array | =arr[0]= |
| Set | Set | =set.has(x)= |
| Keyword | String | =":ns/name"= → ="ns/name"= |
| Atom | Wrapper | =plin.useAtom(atom)= |
| Function | Function | Direct call |

** Working with Atoms

#+BEGIN_SRC javascript
// RECOMMENDED: Use plin utilities
const value = plin.useAtom(atomWrapper);  // Reactive hook - BEST for UI
const current = plin.deref(atomWrapper);  // One-time read - for non-reactive code

// Direct access (if needed)
const stateWrapper = bootApi["state"];

if (stateWrapper.___isAtom) {
  // Get fresh value
  const current = stateWrapper.deref();
  
  // Update with function
  stateWrapper.swap(v => ({...v, count: v.count + 1}));
  
  // Replace entirely
  stateWrapper.reset({ count: 0 });
  
  // Subscribe to changes (returns unwatch function)
  const unwatch = stateWrapper.watch(newVal => console.log(newVal));
}
#+END_SRC

* Development Workflow

** Plain JS Plugins

1. Create/edit =.js= file
2. Refresh browser (no build step)

** JSX/TSX Plugins

*** One-time Build

#+BEGIN_SRC bash
npm run build:plugins
#+END_SRC

*** Watch Mode

#+BEGIN_SRC bash
npm run watch:plugins
#+END_SRC

Then refresh browser after changes.

*** Full Development Flow

Terminal 1:
#+BEGIN_SRC bash
npm run watch:plugins
#+END_SRC

Terminal 2:
#+BEGIN_SRC bash
npm start
#+END_SRC

* Manifest Configuration

** Basic Entry

#+BEGIN_SRC clojure
{:id :my-app.my-plugin
 :type :js
 :envs [:browser]
 :files ["public/plugins/my-plugin.js"]}
#+END_SRC

** With Options

#+BEGIN_SRC clojure
{:id :my-app.my-plugin
 :type :js
 :envs [:browser]
 :enabled false              ; Start disabled
 :files ["public/plugins/my-plugin.js"]}
#+END_SRC

** Fields

| Field | Description |
|-------+-------------|
| =:id= | Unique plugin identifier |
| =:type= | Must be =:js= for JavaScript plugins |
| =:envs= | Environments (=[:browser]= for JS plugins) |
| =:enabled= | Set to =false= to disable by default |
| =:files= | Array with path to compiled JS file |

* Complete Examples

** Simple Counter (TSX)

#+BEGIN_SRC typescript
// plugins-src/counter.tsx
import React, { useState } from 'react';

const CounterPage: React.FC = () => {
  const [count, setCount] = useState(0);
  
  return (
    <div className="p-6 max-w-md mx-auto">
      <div className="bg-white rounded-xl shadow-lg p-8 text-center">
        <h1 className="text-2xl font-bold mb-4">Counter</h1>
        <div className="text-4xl font-bold mb-4">{count}</div>
        <div className="flex gap-2 justify-center">
          <button 
            className="px-4 py-2 bg-red-500 text-white rounded"
            onClick={() => setCount(c => c - 1)}
          >
            -
          </button>
          <button 
            className="px-4 py-2 bg-green-500 text-white rounded"
            onClick={() => setCount(c => c + 1)}
          >
            +
          </button>
        </div>
      </div>
    </div>
  );
};

const CounterIcon = ["svg", {
  className: "w-5 h-5",
  fill: "none",
  stroke: "currentColor",
  viewBox: "0 0 24 24"
}, ["path", {
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: 2,
  d: "M12 4v16m8-8H4"
}]];

export default {
  doc: "Simple Counter Plugin",
  deps: ["plinpt.i-application"],
  contributions: {
    "plinpt.i-application/nav-items": [{
      id: "counter",
      label: "Counter",
      route: "/counter",
      icon: "icon",
      component: "page",
      order: 50
    }]
  },
  beans: {
    "page": { type: "react-component", value: CounterPage },
    "icon": { type: "hiccup", value: CounterIcon }
  }
};
#+END_SRC

** Plugin with useAtom for Reactive State (TSX)

#+BEGIN_SRC typescript
// plugins-src/system-info.tsx
import React from 'react';

interface PlinUtils {
  isAtom: (v: any) => boolean;
  deref: (v: any) => any;
  get: (obj: any, key: string) => any;
  getIn: (obj: any, path: string[]) => any;
  keys: (obj: any) => string[];
  vals: (obj: any) => any[];
  isSet: (v: any) => boolean;
  isArray: (v: any) => boolean;
  toArray: (v: any) => any[];
  useAtom: (atom: any) => any;
  useAtomState: (atom: any) => [any, (v: any) => void];
  navigate: (path: string) => void;
  currentPath: () => string | null;
}

interface BootApi {
  state: any;
}

interface SystemInfoProps {
  bootApi: BootApi;
  plin: PlinUtils;
}

const SystemInfoPage: React.FC<SystemInfoProps> = ({ bootApi, plin }) => {
  // Get the state atom
  const stateAtom = plin.get(bootApi, "state");
  
  // IMPORTANT: useAtom for reactive subscription!
  // Without this, the component won't update when state changes
  const stateValue = plin.useAtom(stateAtom);
  
  // Safe data access with plin utilities
  const plugins = plin.toArray(plin.get(stateValue, "all-plugins") || []);
  const disabledIds = plin.get(stateValue, "disabled-ids");
  const disabledCount = plin.isSet(disabledIds) ? disabledIds.size : 0;
  
  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-4">System Info</h1>
      <div className="bg-white rounded-lg shadow p-4">
        <p className="mb-2">Loaded plugins: <strong>{plugins.length}</strong></p>
        <p>Disabled plugins: <strong>{disabledCount}</strong></p>
      </div>
      <p className="mt-4 text-sm text-gray-500">
        This component uses plin.useAtom() - try enabling/disabling plugins 
        and watch the counts update automatically!
      </p>
    </div>
  );
};

// Factory function for injection
const createSystemInfoPage = (bootApi: BootApi, plin: PlinUtils) => {
  return () => <SystemInfoPage bootApi={bootApi} plin={plin} />;
};

export default {
  doc: "System Info Plugin demonstrating useAtom for reactive state",
  deps: ["plinpt.i-application", "plin.boot", "plinpt.i-js-utils"],
  contributions: {
    "plinpt.i-application/nav-items": [{
      id: "system-info",
      label: "System Info",
      route: "/system-info",
      icon: "icon",
      component: "page",
      order: 200
    }]
  },
  beans: {
    "page": { 
      type: "react-component", 
      value: createSystemInfoPage,
      inject: ["plin.boot/api", "plinpt.i-js-utils/api"]
    },
    "icon": { 
      type: "hiccup", 
      value: ["svg", { className: "w-5 h-5", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor" },
        ["path", { strokeWidth: 2, d: "M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" }]
      ]
    }
  }
};
#+END_SRC

* Troubleshooting

** Common Issues

| Problem | Cause | Solution |
|---------+-------+----------|
| Plugin doesn't appear | Missing =return= (plain JS) | Add =return {...}= at end |
| Plugin doesn't appear | Missing =export default= (TSX) | Add =export default {...}= |
| Icon not showing | Wrong bean type | Use =type: "hiccup"= |
| Build fails | Syntax error | Check console for esbuild errors |
| "React is not defined" | Missing external config | Ensure =external: ['react']= in esbuild |
| Injection undefined | Wrong bean key | Check spelling of inject key |
| Component not updating | Not using reactive hook | Use =plin.useAtom()= instead of =plin.deref()= |
| Keys not found | Using dot notation | Use =plin.get(obj, "key-name")= |

** Debugging

*** Check Build Output

#+BEGIN_SRC bash
cat public/plugins/my-plugin.js | tail -5
#+END_SRC

Should end with:
#+BEGIN_SRC javascript
return __PLIN_PLUGIN__.default;
#+END_SRC

*** Browser Console

Look for:
- =load-js-plugins: loading= - Plugin being fetched
- =wrap-js-plugin: created plugin= - Successfully wrapped
- Errors during load/wrap

*** Verify Manifest

Ensure your =plin.edn= entry has:
- =:type :js=
- =:envs [:browser]=
- Correct file path

*** Verify Plin Utilities

#+BEGIN_SRC javascript
const createPage = (plin) => {
    console.log("plin utilities:", plin);
    console.log("available methods:", Object.keys(plin));
    return () => React.createElement("div", null, "Test");
};
#+END_SRC

* Best Practices

1. *Always inject plin utilities* - Add ="plinpt.i-js-utils"= to deps for any plugin working with CLJS data
2. *Use =plin.useAtom()= for reactive data* - This is essential! Without it, your UI won't update when atoms change
3. *Use =plin.get()= for data access* - Handles keyword-to-string conversion safely
4. *Use Hiccup for icons* - Icons must be arrays, not React components
5. *Keep bean names simple* - Use lowercase with hyphens: ="my-page"=
6. *Declare all dependencies* - List plugin deps in =deps= array
7. *Use TypeScript* - Better IDE support and error catching
8. *Factory pattern for injection* - When using =inject=, value must be a factory
9. *Test in browser* - Always verify plugins load correctly
10. *Watch mode for development* - Use =npm run watch:plugins= for faster iteration

* File Structure Reference

#+BEGIN_SRC text
my-app/
├── plugins-src/              # TSX/JSX source files
│   ├── my-plugin.tsx
│   └── tsconfig.json         # TypeScript config (optional, for IDE)
├── public/
│   └── plugins/              # Compiled output (gitignored)
│       └── my-plugin.js
├── src/                      # ClojureScript source
│   └── plinpt_extras/
│       └── showcase/         # Example JS plugins
│           ├── game_2048.js
│           └── plugin_inspector.js
├── esbuild.plugins.js        # Build configuration
├── manifest.edn              # Plugin manifest
├── package.json
└── tsconfig.json             # Root TypeScript config
#+END_SRC

* Reference Examples

The platform includes working example plugins demonstrating best practices:

** =src/plinpt_extras/showcase/game_2048.js=

A complete 2048 game implementation showing:
- Complex React state with =useState=
- Event handling with =useEffect= and =useCallback=
- Keyboard and touch input handling
- Using =plin.currentPath()= for route information
- Game logic in pure JavaScript

** =src/plinpt_extras/showcase/plugin_inspector.js=

A system introspection plugin showing:
- *=plin.useAtom()=* for reactive state updates (the key feature!)
- Injecting multiple dependencies (=plin.boot/api= and =plinpt.i-js-utils/api=)
- Using =plin.get()= and =plin.toArray()= for safe data access
- Using =plin.isSet()= for type checking
- Interacting with the plugin system (enable/disable plugins)
- Automatic UI updates when system state changes

This is the best example to study for understanding how to build reactive JS plugins that respond to CLJS state changes.
